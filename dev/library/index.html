<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · GraphPlayground.jl</title><meta name="title" content="Library · GraphPlayground.jl"/><meta property="og:title" content="Library · GraphPlayground.jl"/><meta property="twitter:title" content="Library · GraphPlayground.jl"/><meta name="description" content="Documentation for GraphPlayground.jl."/><meta property="og:description" content="Documentation for GraphPlayground.jl."/><meta property="twitter:description" content="Documentation for GraphPlayground.jl."/><meta property="og:url" content="https://dgleich.github.io/GraphPlayground.jl/library/"/><meta property="twitter:url" content="https://dgleich.github.io/GraphPlayground.jl/library/"/><link rel="canonical" href="https://dgleich.github.io/GraphPlayground.jl/library/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphPlayground.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../forces/">Forces</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#User-Friendly-Interfaces"><span>User Friendly Interfaces</span></a></li><li><a class="tocitem" href="#Force-Simulator-Interface"><span>Force Simulator Interface</span></a></li><li><a class="tocitem" href="#Extra-window-help"><span>Extra window help</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../mouse-pointer-repulsion/">Example: Mouse Pointer Repulsion and Collision</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dgleich/GraphPlayground.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dgleich/GraphPlayground.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="User-Friendly-Interfaces"><a class="docs-heading-anchor" href="#User-Friendly-Interfaces">User Friendly Interfaces</a><a id="User-Friendly-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#User-Friendly-Interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.playground" href="#GraphPlayground.playground"><code>GraphPlayground.playground</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">playground(g; 
  [link_options = (;iterations=1,distance=30),] 
  [center_options = NamedTuple(),]
  [charge_options = NamedTuple(),]
  [graphplot_options = NamedTuple(),]
  [initial_iterations = 10,]
  [labels = map(i-&gt;string(i), 1:nv(g)),]
  [verbose = false,]
  [kwargs...] )
playground(g, sim; kwargs...)</code></pre><p>Create a graph playground window from the graph <code>g</code>.</p><p>The value that is returned is a <code>Playground</code> object, which is a thin  wrapper around the window, the simulation, and the Makie axis.</p><p><strong>Optional parameters</strong></p><ul><li><code>link_options</code>: These options are passed to the <code>LinkForce</code><code>constructor.  The default is</code>(;iterations=1,distance=30)`. This is generally good. For grid graphs, set iterations higher to get a better layout.</li><li><code>center_options</code>: These options are passed to the <code>PositionForce</code> constructor.</li><li><code>charge_options</code>: These options are passed to the <code>ManyBodyForce</code> constructor.</li><li><code>graphplot_options</code>: These options are passed to the <code>graphplot!</code> function.</li><li><code>initial_iterations</code>: The number of layout iteration to run before the first display. The default is 10. </li><li><code>labels</code>: A list of strings to display for the node identifiers. By default these  are the numeric node ids</li><li><code>verbose</code>: If true, additional information is shown in the lower left corner of the plot.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">g = wheel_graph(10)
playground(g)</code></pre><p>For a grid, this often looks much better</p><pre><code class="language-julia hljs">g = grid([10,10])
playground(g; 
  link_options=(;iterations=10, strength=1, distance=20))</code></pre><p><strong>See also</strong></p><p><a href="#GraphPlayground.ForceSimulation"><code>ForceSimulation</code></a>, <a href="#GraphPlayground.LinkForce"><code>LinkForce</code></a>, <a href="#GraphPlayground.ManyBodyForce"><code>ManyBodyForce</code></a>, <a href="#GraphPlayground.PositionForce"><code>PositionForce</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/playground.jl#L139-L184">source</a></section></article><h2 id="Force-Simulator-Interface"><a class="docs-heading-anchor" href="#Force-Simulator-Interface">Force Simulator Interface</a><a id="Force-Simulator-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Force-Simulator-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.ForceSimulation" href="#GraphPlayground.ForceSimulation"><code>GraphPlayground.ForceSimulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ForceSimulation([PositionType,] nodes; [...]) 
ForceSimulation(positions, nodes; [rng,] [alpha,] [velocity_decay,] forcelist...)</code></pre><p>Create a force simulator for a set of positions. This evaluates and evolves the positions  based on the forces applied. It is designed to be used with evaluating a dynamic force directed graph layout including attractive forces for edges and repulsive forces for nodes.  But it may have other uses as well. For instance, collision forces can be used to simulate packed bubble charts with various radii. </p><p><strong>Arguments</strong></p><ul><li><code>nodes</code> is any array of nodes. This can be very simple, i.e. 1:n, or  a list of objects. The objects must be used consistent with other forces involved. </li><li><code>PositionType</code> is the type of the positions. Using <code>Point2f</code> is recommended and the default </li><li><code>positions</code> is an array of initial positions. The position type is determined by the elements of </li></ul><p>the array. </p><ul><li><code>forcelist</code> is a trailing list of forces. The names of these forces do not matter.  The order is the order in which they are applied. While forcelist is not syntactically required, it is semantically required as otherwise the simulation will not do anything.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>rng</code> is a random number generator. This is used for the initial positions and for  any random perturbations if there are degeneracies. The default is to use    a deterministic generator so that the results are reproducible.</li><li><code>alpha</code> is the cooling stepper. This is used to control the rate of convergence. See <a href="#GraphPlayground.CoolingStepper"><code>GraphPlayground.CoolingStepper</code></a> for more information.</li><li><code>velocity_decay</code> is the factor by which the velocities are decayed each step. Setting this to 1 will not decay the velocities. Setting it to 0 will stop all motion. The default is 0.6.  </li></ul><p><strong>Usage</strong></p><p>Here is an example that packs balls of different sizes into a region around the point (0,0). </p><pre><code class="language-julia hljs">radii = 1:10
sim = ForceSimulation(1:10; 
  collide=CollisionForce(radius=radii, iterations=3),
  center=PositionForce(target=(0,0)))
initial_positions = copy(sim.positions) 
step!(sim, 100) # run 100 steps 
plot(sim.positions; markersize=(radii .- 0.5).*pi/1.11, 
  markerspace=:data, strokewidth=0.25, strokecolor=:white)  # weird 1.11 to get the right size, add 0.05 </code></pre><p><strong>Forces</strong></p><p>The list of forces can have silly names if you wish. The names are not used other than   for display. For example, this is entirely valid:</p><pre><code class="language-julia hljs">sim = ForceSimulation(1:10; 
  collide=CollisionForce(radius=radii, iterations=3),
  push_nodes_to_middle=PositionForce(target=(0,0))
  push_nodes_to_offset=PositionForce(target=(10,10)))</code></pre><p>Of course, that generates a very useless simulator.     </p><p><strong>Forces</strong></p><ul><li><a href="#GraphPlayground.LinkForce"><code>LinkForce</code></a>: This force applies a spring force to all edges in the graph.  The force is proportional to the distance between the nodes.</li><li><a href="#GraphPlayground.ManyBodyForce"><code>ManyBodyForce</code></a>: This force applies a repulsive force between all nodes.  The force is proportional to the inverse square of the distance between the nodes.</li><li><a href="#GraphPlayground.PositionForce"><code>PositionForce</code></a>: This force applies a force to all nodes to move them to a target position.  This is useful for centering the graph or pushing nodes to the edge.</li><li><a href="#GraphPlayground.CollisionForce"><code>CollisionForce</code></a>: This force applies a repulsive force between all positions.  The force is proportional to the sum of the radii of the nodes.</li><li><a href="#GraphPlayground.CenterForce"><code>CenterForce</code></a>: This force directly centers all the positions. </li></ul><p><strong>Data</strong></p><p>The simulator maintains the following data that are useful:</p><ul><li><code>positions</code>: The current positions of the nodes.</li><li><code>velocities</code>: The current velocities of the nodes.</li></ul><p>You can access these directly.</p><p><strong>Methods</strong></p><p>To fix a node in place, use <code>fixnode!(sim, i, pos)</code>. To free a node, use <code>freenode!(sim, i)</code>. To take a step, use <code>step!(sim)</code>. To take multiple steps, use <code>step!(sim, n)</code>.</p><p><strong>See also</strong></p><p><a href="#GraphPlayground.step!"><code>step!</code></a>, <a href="#GraphPlayground.fixnode!"><code>fixnode!</code></a>, <a href="#GraphPlayground.freenode!"><code>freenode!</code></a>, <a href="#GraphPlayground.LinkForce"><code>LinkForce</code></a>, <a href="#GraphPlayground.ManyBodyForce"><code>ManyBodyForce</code></a>, <a href="#GraphPlayground.PositionForce"><code>PositionForce</code></a>, <a href="#GraphPlayground.CollisionForce"><code>CollisionForce</code></a>, <a href="#GraphPlayground.CenterForce"><code>CenterForce</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/simulation.jl#L12-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.fixnode!" href="#GraphPlayground.fixnode!"><code>GraphPlayground.fixnode!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixnode!(sim::ForceSimulation, i, pos)</code></pre><p>Fix the position of a node in the simulation. This will prevent the node from moving. This importantly keeps the velocity of the node set to 0, which will prevent the node from updating other implicit positions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/simulation.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.freenode!" href="#GraphPlayground.freenode!"><code>GraphPlayground.freenode!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freenode!(sim::ForceSimulation, i)</code></pre><p>Remove the fixed position of a node in the simulation. This will allow the node to move.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/simulation.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.step!" href="#GraphPlayground.step!"><code>GraphPlayground.step!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">step!(sim) # take one step 
step!(sim, n) # take n steps</code></pre><p>Take a step of the force simulator. This will apply all forces in the order they were added to the simulator. The forces are applied to the positions and velocities. The velocities are then decayed by the <code>velocity_decay</code> factor.</p><p>See <a href="#GraphPlayground.ForceSimulation"><code>ForceSimulation</code></a> for more information and an example. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/simulation.jl#L144-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.LinkForce" href="#GraphPlayground.LinkForce"><code>GraphPlayground.LinkForce</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinkForce(;edges)
LinkForce(;edges, [strength], [distance], [bias], [iterations], [random])</code></pre><p>A link force computes forces between nodes that emulate a strong connection.  This is useful for graphs where the edges represent strong connections between nodes.</p><p>The force applied between two nodes is based on the strength of the link, the distance, the strength of the edge. The bias of the edge is used to determine how much the nodes should move.</p><p>For an edge between <code>src</code>, <code>dst</code>, let <span>$d$</span> be the difference vector  between the position of <code>dst</code> and <code>src</code> <em>with their velocity corrections included</em>. The total force is <span>$f = \alpha \cdot s \cdot (||d|| - l) / ||d||$</span> where <span>$l$</span> is the ideal distance and <span>$s$</span> is the strength of the link. The force is applied to the velocity of the nodes proportional to the bias of the edge <span>$\beta$</span></p><pre><code class="nohighlight hljs">  `vel[dst] -=` ``\beta f \cdot d``
  `vel[src] +=` ``(1-\beta) f \cdot d``</code></pre><p>The bias is used to determine how much the nodes should move. If the bias is 0, then the  update is exclusively provided to the <code>src</code> node. If the bias is 1, then the update is  exclusively provided to the <code>dst</code> node.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: An array of edge structures, where each edge structure contains <code>src</code> and <code>dst</code> fields or can be indexed like a tuple with e[1], e[2] as the source and destination nodes. </li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>strength</code>: A function or array of values that determine the strength of the link between two nodes. By default, this is based on the number of edges between the nodes: 1/(min(degree(src), degree(dst))).</li><li><code>distance</code>: A function or array of values that determine the ideal distance between two nodes. By default, this is 30.0.  But this can be a function that takes the edge index and returns a distance.</li><li><code>bias</code>: A function or array of values that determine the bias of the link between two nodes. This is designed to weight how much the nodes should move. It&#39;s designed to make it harder to move high degree nodes. </li><li><code>iterations</code>: The number of iterations to run the link force. The default is 1. Each iteration updates the velocity but not the positions. However, the velocity updates are included in the force calculations. So by running multiple iterations, the forces are more accurate. This is because we update the velocities in-place.  Using large values here are most important for grids or graphs with a lot of structure.   </li><li><code>random</code>: A random number generator. This is used for the random perturbations.  The default is to use a deterministic generator so that the results are reproducible. I can&#39;t imagine why you would need to use this, but it&#39;s here in case someone needs to reproduce something strange. </li></ul><p><strong>Function inputs</strong></p><p>An exmaple of using it with a function is the following</p><pre><code class="language-julia hljs">val = randn(10)
f = LinkForce(;edges=edges, strength=(i,e,src,dst)-&gt;val[src]*val[dst])</code></pre><p>This is called with </p><ul><li><code>i</code>: The index of the edge in the edges array.</li><li><code>e</code>: The edge structure.</li><li><code>src</code>: The source node.</li><li><code>dst</code>: The destination node.</li></ul><p>This same structure is used for all strength, bias, and distance. </p><p><strong>Usage</strong></p><p>LinkForce is usually used as part of a ForceSimulation. Here, we setup something simple with two nodes at distance 1. But that want to be at distance 10 given the edge between them. </p><pre><code class="language-julia hljs">nodes = [1,2]
edgelist = [(1, 2)]
positions = [Point2f(0.0, 0.0), Point2f(1.0, 0.0)]
sim = ForceSimulation(positions, nodes; 
  link=LinkForce(edges=edgelist, strength=10, distance=10.0, bias=0.25))
iforce = sim.forces.link
# iforce is an `InitializedLinkForce` that&#39;s been linked to the simulation
GraphPlayground.force!(0.1, sim, iforce)  # Assume alpha=0.1
sim.velocities</code></pre><p>This example shows how the [<code>LinkForce</code>]computes the velocities of the nodes to move them away from each other. The reason the update is nonsymmetric is because of the bias. This says that we want to move node 1 more than node 2.</p><p><strong>See also</strong></p><p><a href="#GraphPlayground.ForceSimulation"><code>ForceSimulation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/linkforce.jl#L9-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.ManyBodyForce" href="#GraphPlayground.ManyBodyForce"><code>GraphPlayground.ManyBodyForce</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManyBodyForce()
ManyBodyForce(; [strength], [min_distance2], [max_distance2], [theta2], [random])</code></pre><p>Create a force defined by multiple bodies.  This force is used to simulate the repulsion or attraction between nodes of the simulation. If you wish to apply to only  a subset of nodes, you can set the <code>strength</code> to zero for the nodes you wish to ignore. </p><p>This computation is implemented with a space partitioning data structure (current a KDTree) to approximate the impact of distance forces using a far-field approximation (this is often called a  Barnes-Hut approximation, but that doesn&#39;t help understand what is going on). Setting <code>theta2</code> to zero will cause it to  discard the approximation and compute the exact force.  Reasonable values for <code>theta2</code> are between 0.5 (better approximation)  and 1.5 (poor approximation). (This is the square of the <span>$\theta$</span> value commonly used in Barnes-Hut approximations.)</p><p><strong>Arguments</strong></p><ul><li><code>strength</code>: A constant, a function or array of values. The repulsive strength to use, defaults to -30,  which is a repulsive force between nodes. </li><li><code>min_distance2</code>: A constant, that defines a minimum distance between nodes. If the distance between two nodes is less than this value, the force is increased a bit. The default is 1.0.</li><li><code>max_distance2</code>: A constant, that defines a maximum distance between nodes. If the distance between two nodes is greater than this value, the force is ignored. The default is Inf.</li><li><code>theta2</code>: A constant, that defines the accuracy of the approximation. The default is 0.81, which is a reasonable value for most simulations.</li><li><code>random</code>: A random number generator. This is used for the random perturbations.      </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/manybodyforce.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.CollisionForce" href="#GraphPlayground.CollisionForce"><code>GraphPlayground.CollisionForce</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CollisionForce([radius,] [strength])</code></pre><p>Create a collision force. This force is used to simulate collisions between nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/collisionforce.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.PositionForce" href="#GraphPlayground.PositionForce"><code>GraphPlayground.PositionForce</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PositionForce(;[target] [, strength])</code></pre><p><code>PositionForce</code> represents a force that directions nodes of the  simulation towards specific target positions.</p><p><strong>Arguments</strong></p><ul><li><code>target</code>: The target position of each node.  This can be a single value or an array of values.  The default is (0,0), which tries to center the positions. </li><li><code>strength</code>: The strength of the force, which is a real number. The default is 0.1.</li></ul><p><strong>See also</strong></p><p><a href="#GraphPlayground.ForceSimulation"><code>ForceSimulation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/simpleforces.jl#L73-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.CenterForce" href="#GraphPlayground.CenterForce"><code>GraphPlayground.CenterForce</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>CenterForce</code> represents a centering adjustment in a force simulation.  it has two parameters: </p><ul><li><code>center</code>: The center of the force, which can be anything resembling a point</li><li><code>strength</code>: The strength of the force, which is a real number</li></ul><p>Note that CenterForce directly applies the force to the  positions of the nodes in the simulation instead of updating their velocities.</p><p>Use PositionForce to apply a force to the velocities of the nodes instead.  (Also, please don&#39;t combine PositionForce and CenterForce.)</p><p><strong>Example</strong></p><p>rad = 10*rand(100) sim = ForceSimulation(Point2f, eachindex(rad);     center=CenterForce(center, strength=1.0),     collide=CollisionForce(radius=rad)     ) p = scatter(sim.positions, markersize=rad) for i in 1:100     step!(sim)     p[:node_pos][] = sim.positions     sleep(0.5) end    </p><p><strong>See also</strong></p><p><a href="#GraphPlayground.ForceSimulation"><code>ForceSimulation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/simpleforces.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.CoolingStepper" href="#GraphPlayground.CoolingStepper"><code>GraphPlayground.CoolingStepper</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A model of the cooling step in d3-force. The stepper allows dynamic retargeting of the cooling factor, which is useful  in simulations where you want to adjust behavior for user interaction or for  incoming data. </p><p>Once the stepper has reached it&#39;s minimum value, it will return zero for all subsequent steps. </p><p>Usage: ```julia alpha = CoolingStepper() for i=1:10   println(step!(alpha)) end alpha.alpha<em>target = 0.5  for i=1:10   println(step!(alpha)) end alpha.alpha</em>target = 0.0 for i=1:10   println(step!(alpha)) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/utilities.jl#L134-L157">source</a></section></article><h2 id="Extra-window-help"><a class="docs-heading-anchor" href="#Extra-window-help">Extra window help</a><a id="Extra-window-help-1"></a><a class="docs-heading-anchor-permalink" href="#Extra-window-help" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphPlayground.Window" href="#GraphPlayground.Window"><code>GraphPlayground.Window</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Window(loop::Function, scene; [title=&quot;GraphPlayground&quot;, size=(800,800), kwargs...])</code></pre><p>Create a window based on a scene. The window will run the provided <code>loop</code> function ever frame. The loop function should take a single argument, which is the time since the window was opened. This function is a fairly thin wrapper around GLMakie.Screen and GLMakie.display_scene!, but makes it easier to abstract in the future. </p><p><strong>Parameters</strong></p><ul><li><code>loop</code>: A function that will be called every frame.  The function should take a single argument,  which is the time since the window was opened.</li><li><code>scene</code>: The scene to display in the window.</li><li><code>title</code>: The title of the window. Default is &quot;GraphPlayground&quot;.</li><li><code>size</code>: The size of the window. Default is (800,800).</li><li><code>kwargs</code>: Additional keyword arguments to pass to the GLMakie.Screen constructor.</li></ul><p><strong>Example</strong></p><p>This example shows a bunch of points that are going to be pushed away from each other in a simulation of a collision. </p><pre><code class="language-julia hljs">using GeometryBasics, GraphPlayground, GLMakie
scenesize = 500 
n = 100
scene = Scene(camera=campixel!, size=(scenesize, scenesize))
pts = Observable((scenesize/2*rand(Point2f0, n)) .+ (scenesize/4)*Point2f(1,1))
radius = rand(10:20, n)
sim = ForceSimulation(pts[], eachindex(pts[]);
  collide = CollisionForce(radius=radius .+ 2, iterations=3))
scatter!(scene, pts, markersize=pi*radius/1.11)
GraphPlayground.Window(scene; 
  title=&quot;Collision Simulation&quot;, size=(scenesize, scenesize),
  focus_on_show = true) do _ 
  step!(sim)
  pts[] = sim.positions
end </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dgleich/GraphPlayground.jl/blob/028848b0b24e2477595ac3fe79e7962db281c284/src/utilities.jl#L262-L299">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GraphPlayground.CenterForce"><code>GraphPlayground.CenterForce</code></a></li><li><a href="#GraphPlayground.CollisionForce"><code>GraphPlayground.CollisionForce</code></a></li><li><a href="#GraphPlayground.CoolingStepper"><code>GraphPlayground.CoolingStepper</code></a></li><li><a href="#GraphPlayground.ForceSimulation"><code>GraphPlayground.ForceSimulation</code></a></li><li><a href="#GraphPlayground.LinkForce"><code>GraphPlayground.LinkForce</code></a></li><li><a href="#GraphPlayground.ManyBodyForce"><code>GraphPlayground.ManyBodyForce</code></a></li><li><a href="#GraphPlayground.PositionForce"><code>GraphPlayground.PositionForce</code></a></li><li><a href="#GraphPlayground.Window"><code>GraphPlayground.Window</code></a></li><li><a href="#GraphPlayground.fixnode!"><code>GraphPlayground.fixnode!</code></a></li><li><a href="#GraphPlayground.freenode!"><code>GraphPlayground.freenode!</code></a></li><li><a href="#GraphPlayground.playground"><code>GraphPlayground.playground</code></a></li><li><a href="#GraphPlayground.step!"><code>GraphPlayground.step!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../forces/">« Forces</a><a class="docs-footer-nextpage" href="../mouse-pointer-repulsion/">Example: Mouse Pointer Repulsion and Collision »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Monday 23 June 2025 13:18">Monday 23 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
