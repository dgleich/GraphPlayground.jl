var documenterSearchIndex = {"docs":
[{"location":"forces/","page":"Forces","title":"Forces","text":"CurrentModule = GraphPlayground","category":"page"},{"location":"forces/#Forces","page":"Forces","title":"Forces","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"The ForceSimulation is the key dynamics implementation. It is hugely inspired by the excellent d3-force library. It's setup for nice displays instead of scientific accuracy. This includes things like","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"randomly jiggles to avoid singularities. \ngraceful fallbacks and approximations.","category":"page"},{"location":"forces/#How-to-give-information-about-the-data-or-graph-to-influence-the-forces","page":"Forces","title":"How to give information about the data or graph to influence the forces","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"LinkForce takes information about edges along with a number of  additional optional weights. If you wish to specify them yourself you can  provide","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"a constant. This constant is used for all edges\nan array. The array needs to have the same order as the edge input array. \na function. The function is computed once and turned into the array by calling the function for each edge. The function must take the following arguments:   (i,e,src,dst) where   This is called with \ni: The index of the edge in the edges array.\ne: The edge structure.\nsrc: The source node.\ndst: The destination node.","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"You can use this interface for the distance, strength, and bias. ","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"ManyBodyForce takes in a strength argument that determines the impact on each node. If this is positive, the effect is attractive to the node. If it is negative, the effect is repulsive  from the node. As before, this can be ","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"a constant. This constant is used for all nodes\nan array. The array needs to have the same order as the node input array. \na function. The function is computed once and turned into the array by calling the function for each node. The function is actually just a map over the  nodes input to the force simulation, as in map(f, nodes). ","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"PositionForce takes in a target argument that determines the target postion for each node. ","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"a constant. This constant position is used for all nodes\nan array. The array of positions which needs to have the same order  as the node input array. \na function. The function is computed once and turned into the array by calling the function for each node. The function is actually just a map over the  nodes input to the force simulation, as in map(f, nodes). ","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#User-Friendly-Interfaces","page":"Library","title":"User Friendly Interfaces","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"playground","category":"page"},{"location":"library/#GraphPlayground.playground","page":"Library","title":"GraphPlayground.playground","text":"playground(g; \n  [link_options = (;iterations=1,distance=30),] \n  [center_options = NamedTuple(),]\n  [charge_options = NamedTuple(),]\n  [graphplot_options = NamedTuple(),]\n  [initial_iterations = 10,]\n  [labels = map(i->string(i), 1:nv(g)),]\n  [verbose = false,]\n  [kwargs...] )\nplayground(g, sim; kwargs...)\n\nCreate a graph playground window from the graph g.\n\nThe value that is returned is a Playground object, which is a thin  wrapper around the window, the simulation, and the Makie axis.\n\nOptional parameters\n\nlink_options: These options are passed to the LinkForceconstructor.  The default is(;iterations=1,distance=30)`. This is generally good. For grid graphs, set iterations higher to get a better layout.\ncenter_options: These options are passed to the PositionForce constructor.\ncharge_options: These options are passed to the ManyBodyForce constructor.\ngraphplot_options: These options are passed to the graphplot! function.\ninitial_iterations: The number of layout iteration to run before the first display. The default is 10. \nlabels: A list of strings to display for the node identifiers. By default these  are the numeric node ids\nverbose: If true, additional information is shown in the lower left corner of the plot.\n\nExamples\n\ng = wheel_graph(10)\nplayground(g)\n\nFor a grid, this often looks much better\n\ng = grid([10,10])\nplayground(g; \n  link_options=(;iterations=10, strength=1, distance=20))\n\nSee also\n\nForceSimulation, LinkForce, ManyBodyForce, PositionForce\n\n\n\n\n\n","category":"function"},{"location":"library/#Force-Simulator-Interface","page":"Library","title":"Force Simulator Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ForceSimulation\nfixnode!\nfreenode! \nstep!\nLinkForce\nManyBodyForce\nCollisionForce\nPositionForce\nCenterForce\nGraphPlayground.CoolingStepper","category":"page"},{"location":"library/#GraphPlayground.ForceSimulation","page":"Library","title":"GraphPlayground.ForceSimulation","text":"ForceSimulation([PositionType,] nodes; [...]) \nForceSimulation(positions, nodes; [rng,] [alpha,] [velocity_decay,] forcelist...)\n\nCreate a force simulator for a set of positions. This evaluates and evolves the positions  based on the forces applied. It is designed to be used with evaluating a dynamic force directed graph layout including attractive forces for edges and repulsive forces for nodes.  But it may have other uses as well. For instance, collision forces can be used to simulate packed bubble charts with various radii. \n\nArguments\n\nnodes is any array of nodes. This can be very simple, i.e. 1:n, or  a list of objects. The objects must be used consistent with other forces involved. \nPositionType is the type of the positions. Using Point2f is recommended and the default \npositions is an array of initial positions. The position type is determined by the elements of \n\nthe array. \n\nforcelist is a trailing list of forces. The names of these forces do not matter.  The order is the order in which they are applied. While forcelist is not syntactically required, it is semantically required as otherwise the simulation will not do anything.\n\nOptional Arguments\n\nrng is a random number generator. This is used for the initial positions and for  any random perturbations if there are degeneracies. The default is to use    a deterministic generator so that the results are reproducible.\nalpha is the cooling stepper. This is used to control the rate of convergence. See GraphPlayground.CoolingStepper for more information.\nvelocity_decay is the factor by which the velocities are decayed each step. Setting this to 1 will not decay the velocities. Setting it to 0 will stop all motion. The default is 0.6.  \n\nUsage\n\nHere is an example that packs balls of different sizes into a region around the point (0,0). \n\nradii = 1:10\nsim = ForceSimulation(1:10; \n  collide=CollisionForce(radius=radii, iterations=3),\n  center=PositionForce(target=(0,0)))\ninitial_positions = copy(sim.positions) \nstep!(sim, 100) # run 100 steps \nplot(sim.positions; markersize=(radii .- 0.5).*pi/1.11, \n  markerspace=:data, strokewidth=0.25, strokecolor=:white)  # weird 1.11 to get the right size, add 0.05 \n\nForces\n\nThe list of forces can have silly names if you wish. The names are not used other than   for display. For example, this is entirely valid:\n\nsim = ForceSimulation(1:10; \n  collide=CollisionForce(radius=radii, iterations=3),\n  push_nodes_to_middle=PositionForce(target=(0,0))\n  push_nodes_to_offset=PositionForce(target=(10,10)))\n\nOf course, that generates a very useless simulator.     \n\nForces\n\nLinkForce: This force applies a spring force to all edges in the graph.  The force is proportional to the distance between the nodes.\nManyBodyForce: This force applies a repulsive force between all nodes.  The force is proportional to the inverse square of the distance between the nodes.\nPositionForce: This force applies a force to all nodes to move them to a target position.  This is useful for centering the graph or pushing nodes to the edge.\nCollisionForce: This force applies a repulsive force between all positions.  The force is proportional to the sum of the radii of the nodes.\nCenterForce: This force directly centers all the positions. \n\nData\n\nThe simulator maintains the following data that are useful:\n\npositions: The current positions of the nodes.\nvelocities: The current velocities of the nodes.\n\nYou can access these directly.\n\nMethods\n\nTo fix a node in place, use fixnode!(sim, i, pos). To free a node, use freenode!(sim, i). To take a step, use step!(sim). To take multiple steps, use step!(sim, n).\n\nSee also\n\nstep!, fixnode!, freenode!, LinkForce, ManyBodyForce, PositionForce, CollisionForce, CenterForce\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphPlayground.fixnode!","page":"Library","title":"GraphPlayground.fixnode!","text":"fixnode!(sim::ForceSimulation, i, pos)\n\nFix the position of a node in the simulation. This will prevent the node from moving. This importantly keeps the velocity of the node set to 0, which will prevent the node from updating other implicit positions. \n\n\n\n\n\n","category":"function"},{"location":"library/#GraphPlayground.freenode!","page":"Library","title":"GraphPlayground.freenode!","text":"freenode!(sim::ForceSimulation, i)\n\nRemove the fixed position of a node in the simulation. This will allow the node to move.    \n\n\n\n\n\n","category":"function"},{"location":"library/#GraphPlayground.step!","page":"Library","title":"GraphPlayground.step!","text":"step!(sim) # take one step \nstep!(sim, n) # take n steps\n\nTake a step of the force simulator. This will apply all forces in the order they were added to the simulator. The forces are applied to the positions and velocities. The velocities are then decayed by the velocity_decay factor.\n\nSee ForceSimulation for more information and an example. \n\n\n\n\n\n","category":"function"},{"location":"library/#GraphPlayground.LinkForce","page":"Library","title":"GraphPlayground.LinkForce","text":"LinkForce(;edges)\nLinkForce(;edges, [strength], [distance], [bias], [iterations], [random])\n\nA link force computes forces between nodes that emulate a strong connection.  This is useful for graphs where the edges represent strong connections between nodes.\n\nThe force applied between two nodes is based on the strength of the link, the distance, the strength of the edge. The bias of the edge is used to determine how much the nodes should move.\n\nFor an edge between src, dst, let d be the difference vector  between the position of dst and src with their velocity corrections included. The total force is f = alpha cdot s cdot (d - l)  d where l is the ideal distance and s is the strength of the link. The force is applied to the velocity of the nodes proportional to the bias of the edge beta\n\n  `vel[dst] -=` ``\\beta f \\cdot d``\n  `vel[src] +=` ``(1-\\beta) f \\cdot d``\n\nThe bias is used to determine how much the nodes should move. If the bias is 0, then the  update is exclusively provided to the src node. If the bias is 1, then the update is  exclusively provided to the dst node.\n\nArguments\n\nedges: An array of edge structures, where each edge structure contains src and dst fields or can be indexed like a tuple with e[1], e[2] as the source and destination nodes. \n\nOptional Arguments\n\nstrength: A function or array of values that determine the strength of the link between two nodes. By default, this is based on the number of edges between the nodes: 1/(min(degree(src), degree(dst))).\ndistance: A function or array of values that determine the ideal distance between two nodes. By default, this is 30.0.  But this can be a function that takes the edge index and returns a distance.\nbias: A function or array of values that determine the bias of the link between two nodes. This is designed to weight how much the nodes should move. It's designed to make it harder to move high degree nodes. \niterations: The number of iterations to run the link force. The default is 1. Each iteration updates the velocity but not the positions. However, the velocity updates are included in the force calculations. So by running multiple iterations, the forces are more accurate. This is because we update the velocities in-place.  Using large values here are most important for grids or graphs with a lot of structure.   \nrandom: A random number generator. This is used for the random perturbations.  The default is to use a deterministic generator so that the results are reproducible. I can't imagine why you would need to use this, but it's here in case someone needs to reproduce something strange. \n\nFunction inputs\n\nAn exmaple of using it with a function is the following\n\nval = randn(10)\nf = LinkForce(;edges=edges, strength=(i,e,src,dst)->val[src]*val[dst])\n\nThis is called with \n\ni: The index of the edge in the edges array.\ne: The edge structure.\nsrc: The source node.\ndst: The destination node.\n\nThis same structure is used for all strength, bias, and distance. \n\nUsage\n\nLinkForce is usually used as part of a ForceSimulation. Here, we setup something simple with two nodes at distance 1. But that want to be at distance 10 given the edge between them. \n\nnodes = [1,2]\nedgelist = [(1, 2)]\npositions = [Point2f(0.0, 0.0), Point2f(1.0, 0.0)]\nsim = ForceSimulation(positions, nodes; \n  link=LinkForce(edges=edgelist, strength=10, distance=10.0, bias=0.25))\niforce = sim.forces.link\n# iforce is an `InitializedLinkForce` that's been linked to the simulation\nGraphPlayground.force!(0.1, sim, iforce)  # Assume alpha=0.1\nsim.velocities\n\nThis example shows how the [LinkForce]computes the velocities of the nodes to move them away from each other. The reason the update is nonsymmetric is because of the bias. This says that we want to move node 1 more than node 2.\n\nSee also\n\nForceSimulation\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphPlayground.ManyBodyForce","page":"Library","title":"GraphPlayground.ManyBodyForce","text":"ManyBodyForce()\nManyBodyForce(; [strength], [min_distance2], [max_distance2], [theta2], [random])\n\nCreate a force defined by multiple bodies.  This force is used to simulate the repulsion or attraction between nodes of the simulation. If you wish to apply to only  a subset of nodes, you can set the strength to zero for the nodes you wish to ignore. \n\nThis computation is implemented with a space partitioning data structure (current a KDTree) to approximate the impact of distance forces using a far-field approximation (this is often called a  Barnes-Hut approximation, but that doesn't help understand what is going on). Setting theta2 to zero will cause it to  discard the approximation and compute the exact force.  Reasonable values for theta2 are between 0.5 (better approximation)  and 1.5 (poor approximation). (This is the square of the theta value commonly used in Barnes-Hut approximations.)\n\nArguments\n\nstrength: A constant, a function or array of values. The repulsive strength to use, defaults to -30,  which is a repulsive force between nodes. \nmin_distance2: A constant, that defines a minimum distance between nodes. If the distance between two nodes is less than this value, the force is increased a bit. The default is 1.0.\nmax_distance2: A constant, that defines a maximum distance between nodes. If the distance between two nodes is greater than this value, the force is ignored. The default is Inf.\ntheta2: A constant, that defines the accuracy of the approximation. The default is 0.81, which is a reasonable value for most simulations.\nrandom: A random number generator. This is used for the random perturbations.      \n\n\n\n\n\n","category":"type"},{"location":"library/#GraphPlayground.CollisionForce","page":"Library","title":"GraphPlayground.CollisionForce","text":"CollisionForce([radius,] [strength])\n\nCreate a collision force. This force is used to simulate collisions between nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphPlayground.PositionForce","page":"Library","title":"GraphPlayground.PositionForce","text":"PositionForce(;[target] [, strength])\n\nPositionForce represents a force that directions nodes of the  simulation towards specific target positions.\n\nArguments\n\ntarget: The target position of each node.  This can be a single value or an array of values.  The default is (0,0), which tries to center the positions. \nstrength: The strength of the force, which is a real number. The default is 0.1.\n\nSee also\n\nForceSimulation\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphPlayground.CenterForce","page":"Library","title":"GraphPlayground.CenterForce","text":"CenterForce represents a centering adjustment in a force simulation.  it has two parameters: \n\ncenter: The center of the force, which can be anything resembling a point\nstrength: The strength of the force, which is a real number\n\nNote that CenterForce directly applies the force to the  positions of the nodes in the simulation instead of updating their velocities.\n\nUse PositionForce to apply a force to the velocities of the nodes instead.  (Also, please don't combine PositionForce and CenterForce.)\n\nExample\n\nrad = 10*rand(100) sim = ForceSimulation(Point2f, eachindex(rad);     center=CenterForce(center, strength=1.0),     collide=CollisionForce(radius=rad)     ) p = scatter(sim.positions, markersize=rad) for i in 1:100     step!(sim)     p[:node_pos][] = sim.positions     sleep(0.5) end    \n\nSee also\n\nForceSimulation\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphPlayground.CoolingStepper","page":"Library","title":"GraphPlayground.CoolingStepper","text":"A model of the cooling step in d3-force. The stepper allows dynamic retargeting of the cooling factor, which is useful  in simulations where you want to adjust behavior for user interaction or for  incoming data. \n\nOnce the stepper has reached it's minimum value, it will return zero for all subsequent steps. \n\nUsage: ```julia alpha = CoolingStepper() for i=1:10   println(step!(alpha)) end alpha.alphatarget = 0.5  for i=1:10   println(step!(alpha)) end alpha.alphatarget = 0.0 for i=1:10   println(step!(alpha)) end\n\n\n\n\n\n","category":"type"},{"location":"library/#Extra-window-help","page":"Library","title":"Extra window help","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GraphPlayground.Window","category":"page"},{"location":"library/#GraphPlayground.Window","page":"Library","title":"GraphPlayground.Window","text":"Window(loop::Function, scene; [title=\"GraphPlayground\", size=(800,800), kwargs...])\n\nCreate a window based on a scene. The window will run the provided loop function ever frame. The loop function should take a single argument, which is the time since the window was opened. This function is a fairly thin wrapper around GLMakie.Screen and GLMakie.display_scene!, but makes it easier to abstract in the future. \n\nParameters\n\nloop: A function that will be called every frame.  The function should take a single argument,  which is the time since the window was opened.\nscene: The scene to display in the window.\ntitle: The title of the window. Default is \"GraphPlayground\".\nsize: The size of the window. Default is (800,800).\nkwargs: Additional keyword arguments to pass to the GLMakie.Screen constructor.\n\nExample\n\nThis example shows a bunch of points that are going to be pushed away from each other in a simulation of a collision. \n\nusing GeometryBasics, GraphPlayground, GLMakie\nscenesize = 500 \nn = 100\nscene = Scene(camera=campixel!, size=(scenesize, scenesize))\npts = Observable((scenesize/2*rand(Point2f0, n)) .+ (scenesize/4)*Point2f(1,1))\nradius = rand(10:20, n)\nsim = ForceSimulation(pts[], eachindex(pts[]);\n  collide = CollisionForce(radius=radius .+ 2, iterations=3))\nscatter!(scene, pts, markersize=pi*radius/1.11)\nGraphPlayground.Window(scene; \n  title=\"Collision Simulation\", size=(scenesize, scenesize),\n  focus_on_show = true) do _ \n  step!(sim)\n  pts[] = sim.positions\nend \n\n\n\n\n\n","category":"function"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"CurrentModule = GraphPlayground","category":"page"},{"location":"mouse-pointer-repulsion/#Mouse-Pointer-Collsion-Demo","page":"Example: Mouse Pointer Repulsion and Collision","title":"Mouse Pointer Collsion Demo","text":"","category":"section"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"This is a port of the  mouse pointer repulsion demo from the d3-force library to Julia as an example of how the library works.","category":"page"},{"location":"mouse-pointer-repulsion/#Required-packages","page":"Example: Mouse Pointer Repulsion and Collision","title":"Required packages","text":"","category":"section"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"using GraphPlayground, StableRNGs, GeometryBasics, GLMakie","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"We use GeometryBasics for the Point2f type. ","category":"page"},{"location":"mouse-pointer-repulsion/#Setup-the-nodes.","page":"Example: Mouse Pointer Repulsion and Collision","title":"Setup the nodes.","text":"","category":"section"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"There are going to be n+1 nodes in our simulation. n for each ball  and 1 for the mouse pointer.  These parameters come from the d3 demo. ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"In this case, we allocate one extra node and set it's radius to 1. This is going to represent the mouse pointer. ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"rng = StableRNG(1)\nnballs = 200\nnnodes = nballs + 1\nwidth = 564 \nk = width/nnodes\nradiusdist = k:4k\nradius = rand(rng, radiusdist, nnodes )\nradius[end] = 1","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"Generate initial positions We generate random initial positions without concern for any collisions or overlaps, etc. ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"pos = [Point2f0(rand(rng, 0:width), rand(rng, 0:width)) for _ in 1:nnodes]\npos = pos .- sum(pos) / length(pos) ","category":"page"},{"location":"mouse-pointer-repulsion/#Setup-the-simulation","page":"Example: Mouse Pointer Repulsion and Collision","title":"Setup the simulation","text":"","category":"section"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"We setup the ForceSimulation now. This is going to have a centering force to keep everything at (0,0).  We are going to model collisions for all of the nodes, except with the radius grown by 1 so that they shouldn't look like they are touching.  Finally, we need to setup the repulsion for the mouse pointer. This is done by setting strength for each node to 0 except for the last node. For this one we model a strong repulsive force by setting strength to -width*2/3 (recall that  negative strength corresponds to repulsion). ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"The last thing we change in this simulation is the  alpha option. (Maybe I need a better parameter name.) This controls the simulation \"cooling\", or how we want to force the simulation to settle even if it might not want to settle. In this case, we want to keep the simulation fairly \"hot\", which means we set a target value of alpha to be 0.3. ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"Finally, to mirror the dynamics of the d3-force example,  we set the velocity decay to 0.9. ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"sim = ForceSimulation(\n  pos, # the starting list of positions \n  eachindex(pos); # the list of nodes, it's just all the indices. \n  position=PositionForce(;strength=0.01), # a centering force\n  collide=CollisionForce(;radius=radius.+1,iterations=3), # the collision force \n  charge=ManyBodyForce(strength=(i) -> i==nnodes ? -width*2/3 : 0.0, theta2=0.82),\n  # this creates a strong repulsion from the mouse pointer (which is the \n  # last node)\n  alpha=GraphPlayground.CoolingStepper(alpha_target=0.3),\n  velocity_decay=0.9,)","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"A few notes, as pointed out in a few places, the names of each force do not matter. We simply treat them as a list. The names are meant to help you, the user understand what you are doing or communicate with others. For instance, the following is also fine. (But really, don't do this... )","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"sim = ForceSimulation(\n  pos, # the starting list of positions \n  eachindex(pos); # the list of nodes, it's just all the indices. \n  gamma=PositionForce(;strength=0.01), # a centering force\n  delta=CollisionForce(;radius=radius.+1,iterations=3), # the collision force \n  theta=ManyBodyForce(strength=(i) -> i==nnodes ? -width*2/3 : 0.0, theta2=0.82),\n  # this creates a strong repulsion from the mouse pointer (which is the \n  # last node)\n  alpha=GraphPlayground.CoolingStepper(alpha_target=0.3),\n  velocity_decay=0.9)","category":"page"},{"location":"mouse-pointer-repulsion/#Linking-the-simulation-to-a-Makie-window-and-keeping-it-updated.","page":"Example: Mouse Pointer Repulsion and Collision","title":"Linking the simulation to a Makie window and keeping it updated.","text":"","category":"section"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"Setting up the scene. We first setup a Makie scene to display the  dots. This is \"standard\" dynamic Makie. In this case, we create  a scene. Then we create an Observable array based on the  random initial positions. The idea is that we can update the positions based on the simulation. We setup the plot with a simple scatter. There is a weird scaling to get the radius draw the same way. This was determined by trial and error to get a radius of 10 to look correct.  Each ball will have a small stroke as well. (This is why we need the extra 1 pixel of width in the collision force.)","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"s = Scene(camera = campixel!, size = (width, width))\npos = Observable(sim.positions .+ Point2f0(width/2, width/2))\nscatter!(s, \n  pos,\n  markersize=pi*radius/1.11, # weird scaling to get size right \n  markerspace=:pixel, \n  color=:black,\n  strokewidth=0.5, \n  strokecolor=:white, \n)","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"Now, the heart of this is setting up an update loop. There seems to be no good way to do this in Makie without create a Screen yourself. So we setup a Window function to make it easier. The Window function takes an update function that gets run every frame. (For the Makie  afficionados, this is mapped to the on(screen.render_tick) function.)","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"function update(_) # we don't use the argument \n  mp = mouseposition(s) # get the mouse position\n  fixnode!(sim, nnodes, mp .- Point2f0(width/2, width/2)) # fix the last node to the mouse pointer\n  step!(sim) # take a step in the simulation\n  pos[] = sim.positions .+ Point2f0(width/2, width/2) # update the positions\nend \nGraphPlayground.Window(update, s;\n  title=\"Mouse Pointer Repulsion Demo\")","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"Of course, Julia supports the slick equivalent syntax to make this easier to write:","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"GraphPlayground.Window(s; title=\"Mouse Pointer Repulsion Demo\") do _\n  mp = mouseposition(s) # get the mouse position\n  @show mp \n  fixnode!(sim, nnodes, mp .- Point2f0(width/2, width/2)) # fix the last node to the mouse pointer\n  step!(sim) # take a step in the simulation\n  pos[] = sim.positions .+ Point2f0(width/2, width/2) # update the positions\nend ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"And we have our ","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"We want the simulation to advance at a regular rate. For this reason,  we created a Window type that creates a GLMakie window with a regular  update","category":"page"},{"location":"mouse-pointer-repulsion/","page":"Example: Mouse Pointer Repulsion and Collision","title":"Example: Mouse Pointer Repulsion and Collision","text":"``` Window()","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphPlayground","category":"page"},{"location":"#GraphPlayground","page":"Home","title":"GraphPlayground","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two main components to GraphPlayground.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A \"easy-to-use\" way to play around with a Graphs.jl graph  with an interactive window. \nAn underlying ForceSimulation that handles the dynamics. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the pages in the sidebar for more information. ","category":"page"}]
}
